From 0ef0c9ca61ba208baf2f8911fe5aa2ee481ce464 Mon Sep 17 00:00:00 2001
From: JennyLien <jenny_lien@pegatroncorp.com>
Date: Fri, 19 Feb 2021 17:04:51 +0800
Subject: [PATCH 1/3] Add MFG PCIe test function

---
 cpssEnabler/mainOs/src/gtOs/linux/osLinuxMem.c     |   4 +-
 .../src/appDemo/entryPoints/linux/mfg_fhgw.c       | 288 ++++++++++++++++++++-
 .../appDemo/userExit/dxCh/appDemoDxChEventHandle.c |  20 +-
 .../src/appDemo/userExit/userEventHandler.c        |   1 +
 4 files changed, 305 insertions(+), 8 deletions(-)

diff --git a/cpssEnabler/mainOs/src/gtOs/linux/osLinuxMem.c b/cpssEnabler/mainOs/src/gtOs/linux/osLinuxMem.c
index 78c3240..6374fe4 100644
--- a/cpssEnabler/mainOs/src/gtOs/linux/osLinuxMem.c
+++ b/cpssEnabler/mainOs/src/gtOs/linux/osLinuxMem.c
@@ -854,7 +854,7 @@ GT_VOID *osCacheDmaMalloc
         }
         if (freePtr)
         {
-fprintf(stderr,"Reuse from 'free' chain : Allocating %d bytes for DMA\n", size);
+/* fprintf(stderr,"Reuse from 'free' chain : Allocating %d bytes for DMA\n", size); */
             /* remove from chain */
             *prev = freePtr->next_elem;
             hdrPtr = (OSMEM_NOPOOLS_HDR_STC*)freePtr;
@@ -953,7 +953,7 @@ GT_STATUS osCacheDmaFree
         }
         freePtr = (OSMEM_POOL_FREE_ELEM_PTR)oldHdr;
         freePtr->size = oldHdr->size;
-        fprintf(stderr,"free %d bytes to DMA\n", oldHdr->size);
+        /* fprintf(stderr,"free %d bytes to DMA\n", oldHdr->size); */
         /* put to chain */
         osMutexLock(freeDmaPoolMtx);
         freePtr->next_elem = freeDmaPool;
diff --git a/cpssEnabler/mainSysConfig/src/appDemo/entryPoints/linux/mfg_fhgw.c b/cpssEnabler/mainSysConfig/src/appDemo/entryPoints/linux/mfg_fhgw.c
index 4204ea6..68f7ff1 100644
--- a/cpssEnabler/mainSysConfig/src/appDemo/entryPoints/linux/mfg_fhgw.c
+++ b/cpssEnabler/mainSysConfig/src/appDemo/entryPoints/linux/mfg_fhgw.c
@@ -58,6 +58,8 @@
 #include <appDemo/sysHwConfig/gtAppDemoSysConfig.h>
 #include <appDemo/sysHwConfig/gtAppDemoSysConfigDefaults.h>
 #include <extUtils/osNetworkStack/osNetworkStack.h>
+#include <cpss/dxCh/dxChxGen/networkIf/cpssDxChNetIf.h>    /* Pegatron PCIe stress test add */
+#include <extUtils/rxEventHandler/rxEventHandler.h>       /* Pegatron PCIe stress test add */
 
 #define DEVNUM 0
 #define SFP_AMOUNT        9
@@ -112,6 +114,286 @@ int flag_qsfp_fan_out, flag_qsfp_fan_out_50g = 0;
                          common/h/cpss/common/port/cpssPortManager.h
 **/
 
+/*
+ * Variables about stress test
+ */
+
+#define STRESS_PKT_SIZE       1500 /* 64 */
+#define LOG_PCIE_STRESS_TIME  "/tmp/streeTest_Packet_CPU_time"
+#define DATE_PCIE_TRAFFIC     "date +'%Y/%m/%d %T.%N'"
+
+/* An ARP Request packet :
+ *  // header
+ *  6-byte : DA -- broadcast = FF:FF:FF:FF:FF:FF
+ *  6-byte : SA
+ *  2-byte : frame type -- ARP = 0x0806
+ *  // data
+ *  2-byte : hardware type -- ethernet = 0x0001
+ *  2-byte : protocol type -- IPv4 = 0x0800
+ *  1-byte : hardware length, MAC address length -- ethernet = 6
+ *  1-byte : protocol length -- IPv4 = 4
+ *  2-byte : operation : 1 = request ; 2 = reply
+ *  6-byte : Sender hardware address, SA in request ; or target MAC in reply
+ *  4-byte : Sender protocol address, Source IP  (ex: 192.168.1.1 == 0xC0, 0xA8, 0x01, 0x01)
+ *  6-byte : Target hardware address
+ *  4-byte : Target protocol address
+ * */
+GT_U8 stressPktBuf[STRESS_PKT_SIZE] =
+        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x6D, 0xF0, 0xC0, 0x00, 0x08, 0x06, 0x00, 0x01,
+         0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x03, 0x6D, 0xF0, 0xC0, 0x00, 0xC0, 0xA8, 0x01, 0x01,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xA8, 0x01, 0x6f};
+
+unsigned long long stressGoodCnt, stressErrCnt, stressPktNumSent_perPort, stressPktNumSent, pktOrder;
+int rv_s = -1;
+char cmd_buf[20480] = {0};    /* for execution Linux commands */
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * DO NOT send any packet to the CPU during stress test
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+GT_STATUS MFG_Stress_Test_Rx
+(
+    IN GT_U32                       numOfBuff,
+    IN GT_U8                        *packetBuffs[],
+    IN GT_U32                       buffLen[]
+)
+{
+    GT_U32         i, j;
+    GT_STATUS   rc = GT_OK;
+
+    pktOrder++;
+    if ( pktOrder == 1 )
+    {
+        memset(cmd_buf, 0, sizeof(cmd_buf));
+        sprintf(cmd_buf, "echo \"  # ReceivePacketFromCPU Start time:\" |& tee -a %s", LOG_PCIE_STRESS_TIME);
+        rv_s = system(cmd_buf);
+        memset(cmd_buf, 0, sizeof(cmd_buf));
+        sprintf(cmd_buf, "%s |& tee -a %s", DATE_PCIE_TRAFFIC, LOG_PCIE_STRESS_TIME);
+        rv_s = system(cmd_buf);
+    }
+
+
+#if 0   /* Print out will cause adding test time */
+    memset(cmd_buf, 0, sizeof(cmd_buf));
+    sprintf(cmd_buf, "echo \"[PEGA dbg] packet number %d \" &>> %s", pktOrder, LOG_PCIE_STRESS_TIME);
+    rv_s = system(cmd_buf);
+#endif
+
+    for (i = 0 ; i < numOfBuff ; i++)
+    {
+#if 0   /* Print out will cause adding test time */
+        /* printf("[PEGA dbg] packet number %d\n", i); */
+        for (j = 0 ; j < buffLen[i] ; j++)
+        {
+            printf("%02X ", packetBuffs[i][j]);
+            if (j%16 == 15 || j==buffLen[i]-1)
+                printf("\n");
+        }
+#endif
+
+#if 0   /* Will make CPU busier and also reduce pps throughput */
+        /* buffLen[i]-4: the last 4 bytes are changed; it looks like CRC */
+        if (osMemCmp(packetBuffs[i], stressPktBuf, buffLen[i]-4) == 0)
+            stressGoodCnt++;
+        else
+            stressErrCnt++;
+#else
+        stressGoodCnt++;
+#endif
+    }
+
+    if (stressPktNumSent)    /* this routine handles all the received packets during stress test */
+        rc = GT_NO_MORE;
+
+    /* printf (" @ [debug] stressPktNumSent_perPort = %d , stressPktNumSent = %d \n", stressPktNumSent_perPort, stressPktNumSent); */
+
+    if ((stressGoodCnt + stressErrCnt == stressPktNumSent) || ((stressPktNumSent == 0) && (stressGoodCnt + stressErrCnt == stressPktNumSent_perPort)))
+    {
+        memset(cmd_buf, 0, sizeof(cmd_buf));
+        sprintf(cmd_buf, "echo \"  # ReceivePacketFromCPU End time:\" |& tee -a %s", LOG_PCIE_STRESS_TIME);
+        rv_s = system(cmd_buf);
+        memset(cmd_buf, 0, sizeof(cmd_buf));
+        sprintf(cmd_buf, "%s |& tee -a %s", DATE_PCIE_TRAFFIC, LOG_PCIE_STRESS_TIME);
+        rv_s = system(cmd_buf);
+
+        printf (" @ [debug] stressPktNumSent_perPort = %d , stressPktNumSent = %d \n", stressPktNumSent_perPort, stressPktNumSent);
+
+        printf("\nStress test result :\n"
+               "  Good packet count: %llu\n"
+               "  Error packet count: %llu\n\n",
+               stressGoodCnt, stressErrCnt);
+
+        /* reset data */
+        stressGoodCnt = stressErrCnt = stressPktNumSent = stressPktNumSent_perPort = pktOrder = 0;
+    }
+
+    return rc;
+}
+
+GT_STATUS MFG_Stress_Test_Tx(int portNum, GT_U32 packetNum)
+{
+    GT_U32                      counter;
+    GT_U32                      numOfBufs = 1;
+    GT_U8                       *sendPktBuffList[1];
+    GT_U32                      sendPktBuffLenList[1];
+    GT_UINTPTR                  txEventHndl = 0;
+    GT_STATUS                   rc, tagged = GT_FALSE;
+    CPSS_DXCH_NET_TX_PARAMS_STC pcktParams;
+    CPSS_DXCH_NET_DSA_FORWARD_STC *forwardPtr;
+    GT_U16 vid = 1;
+
+    stressPktNumSent_perPort = packetNum;    /* single port target */
+
+    /* Get per port's vlanID*/
+    GT_U16 * portVID = &vid;
+    rc = cpssDxChBrgVlanPortVidGet(DEVNUM, portNum, CPSS_DIRECTION_INGRESS_E, portVID);
+    if(rc != GT_OK)
+    {
+        printf("\r\n# cpssDxChBrgVlanPortVidGet() get vlan id fail ... \r\n");
+    }
+
+    /* Enable/disable local switching back through the ingress interface for for known Unicast packets. */
+    rc = cpssDxChBrgGenUcLocalSwitchingEnable(DEVNUM, portNum, GT_TRUE);
+    if(rc != GT_OK)
+        return rc;
+
+    /* Function sets local switching of Multicast, known and unknown Unicast, and Broadcast traffic per VLAN. */
+    rc = cpssDxChBrgVlanLocalSwitchingEnableSet(DEVNUM, vid, CPSS_DXCH_BRG_VLAN_LOCAL_SWITCHING_TRAFFIC_TYPE_KNOWN_UC_E, GT_TRUE);
+    if(rc != GT_OK)
+        return rc;
+
+    /* The function enables/disables bypass of the bridge engine per port. */
+    rc = cpssDxChCscdPortBridgeBypassEnableSet(DEVNUM, portNum, GT_FALSE);
+    if(rc != GT_OK)
+        return rc;
+
+    /* in order to see FDB learning on CPU port, make additional settings
+     * API is to Enable/disable learning of new source MAC addresses for packets received on specified port.*/
+    rc = cpssDxChBrgFdbPortLearnStatusSet(DEVNUM, portNum, GT_FALSE, CPSS_LOCK_FRWRD_E);
+    if(rc != GT_OK)
+        return rc;
+
+    /*  Enables or disables forwarding of New MAC Address messages from a specificâ€ŠePort to the CPU. */
+    rc = cpssDxChBrgFdbNaToCpuPerPortSet(DEVNUM, portNum, GT_TRUE);
+    if(rc != GT_OK)
+        return rc;
+
+    /* if we use own device for srcDev arguement we don't want it to be filtered out
+     * API is to Enable/Disable filtering the ingress DSA tagged packets in which source device (Src Dev) equals to local device number. */
+    rc = cpssDxChCscdDsaSrcDevFilterSet(DEVNUM, tagged);
+    if(rc != GT_OK)
+        return rc;
+
+    osMemSet(&pcktParams, 0, sizeof(pcktParams));
+    pcktParams.cookie                               = NULL;
+    pcktParams.packetIsTagged                       = GT_FALSE;
+    pcktParams.sdmaInfo.recalcCrc                   = GT_TRUE;
+    pcktParams.sdmaInfo.txQueue                     = 7;
+    pcktParams.sdmaInfo.evReqHndl                   = txEventHndl;
+    pcktParams.sdmaInfo.invokeTxBufferQueueEvent    = GT_FALSE;
+    /* in BC2 CPU port is cascade port of 4 word type */
+    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(0) == GT_TRUE)
+        pcktParams.dsaParam.commonParams.dsaTagType = CPSS_DXCH_NET_DSA_4_WORD_TYPE_ENT;
+    else
+        pcktParams.dsaParam.commonParams.dsaTagType = CPSS_DXCH_NET_DSA_2_WORD_TYPE_ENT;
+    pcktParams.dsaParam.commonParams.vpt            = 0;
+    pcktParams.dsaParam.commonParams.cfiBit         = 0;
+    pcktParams.dsaParam.commonParams.vid            = vid;
+    pcktParams.dsaParam.commonParams.dropOnSource   = GT_FALSE;
+    pcktParams.dsaParam.commonParams.packetIsLooped = GT_FALSE;
+    pcktParams.dsaParam.dsaType                     = CPSS_DXCH_NET_DSA_CMD_FORWARD_E;
+
+    forwardPtr = &pcktParams.dsaParam.dsaInfo.forward;
+    forwardPtr->dstInterface.type    = CPSS_INTERFACE_PORT_E;
+    forwardPtr->dstInterface.devPort.portNum  = portNum;
+    forwardPtr->dstInterface.devPort.hwDevNum = PRV_CPSS_HW_DEV_NUM_MAC(0);
+    forwardPtr->srcIsTagged          = CPSS_DXCH_BRG_VLAN_PORT_UNTAGGED_CMD_E;
+    forwardPtr->srcHwDev             = DEVNUM;
+    forwardPtr->srcIsTrunk           = GT_FALSE;
+    forwardPtr->source.portNum       = portNum;    /* CPU port 63 */
+    forwardPtr->srcId                = 0;
+    forwardPtr->egrFilterRegistered  = GT_FALSE;
+    forwardPtr->wasRouted            = GT_FALSE;
+    forwardPtr->qosProfileIndex      = 0;
+    forwardPtr->isTrgPhyPortValid    = GT_FALSE;
+    forwardPtr->dstEport             = portNum;
+    forwardPtr->tag0TpidIndex        = 0;
+    forwardPtr->origSrcPhyIsTrunk    = GT_FALSE;
+    forwardPtr->origSrcPhy.trunkId   = 0;
+    forwardPtr->origSrcPhy.portNum   = 0;
+    forwardPtr->phySrcMcFilterEnable = GT_FALSE;
+
+    sendPktBuffLenList[0] = STRESS_PKT_SIZE;
+    sendPktBuffList[0] = cpssOsCacheDmaMalloc(sendPktBuffLenList[0]*sizeof(GT_U8));
+    osMemCpy(sendPktBuffList[0], stressPktBuf, STRESS_PKT_SIZE);
+#if 0   /* Print out will cause adding test time */
+    memset(cmd_buf, 0, sizeof(cmd_buf));
+    sprintf(cmd_buf, "echo \"  # Port %d SendPacketFromCPU Start time:\" &>> %s", portNum, LOG_PCIE_STRESS_TIME);
+    rv_s = system(cmd_buf);
+    memset(cmd_buf, 0, sizeof(cmd_buf));
+    sprintf(cmd_buf, "%s &>> %s", DATE_PCIE_TRAFFIC, LOG_PCIE_STRESS_TIME);
+    rv_s = system(cmd_buf);
+#endif
+    /* ======================================================================================================================== */
+    /* cpssDxChBrgVlanIpCntlToCpuSet:
+     * Enable/disable IP control traffic trapping/mirroring to CPU.
+     *     IN GT_U8  devNum,
+     *     IN GT_U16 vlanId,
+     *     IN CPSS_DXCH_BRG_IP_CTRL_TYPE_ENT ipCntrlType
+     * */
+     /*
+      * rc = cpssDxChBrgVlanIpCntlToCpuSet(DEVNUM, 1, CPSS_DXCH_BRG_IP_CTRL_IPV4_IPV6_E);
+     if (rc != GT_OK)
+        printf(" [MFG] cpssDxChBrgVlanIpCntlToCpuSet fail , rc = %d\n", rc); */
+
+    /* cpssDxChBrgGenArpBcastToCpuCmdSet:
+     * Enables trapping or mirroring to CPU ARP Broadcast packets for all VLANs or ports.
+     *     CPSS_DXCH_ARP_BCAST_CMD_MODE_VLAN_E: set ARP broadcast command for all VLANs  <--> CPSS_DXCH_ARP_BCAST_CMD_MODE_PORT_E
+     *     CPSS_PACKET_CMD_MIRROR_TO_CPU_E:     mirror packet to CPU  <--> CPSS_PACKET_CMD_FORWARD_E , CPSS_PACKET_CMD_TRAP_TO_CPU_E
+     *
+     * For ARP broadcast received on VLAN - IPv4/IPv6 Control Traffic To CPU must be enabled by function cpssDxChBrgVlanIpCntlToCpuSet;
+     * For ARP broadcast received on port - ARP Broadcast Trap To CPU must be enabled by function cpssDxChBrgGenArpTrapEnable
+     * */
+    rc = cpssDxChBrgGenArpBcastToCpuCmdSet(DEVNUM, CPSS_DXCH_ARP_BCAST_CMD_MODE_PORT_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E);
+    if (rc != GT_OK)
+        printf(" [MFG] cpssDxChBrgGenArpBcastToCpuCmdSet fail , rc = %d\n", rc);
+
+    /* cpssDxChBrgGenArpTrapEnable:
+     * Enable/disable trapping ARP Broadcast packets to the CPU.
+     *     IN GT_U8       devNum,
+     *     IN GT_PORT_NUM portNum,
+     *     IN GT_BOOL     enable : GT_TRUE  - ARP Broadcast packets received on this port are trapped to the CPU;
+     *                             GT_FALSE - ARP Broadcast packets received on this port are not trapped to the CPU.
+
+     * */
+    rc = cpssDxChBrgGenArpTrapEnable(DEVNUM, portNum, GT_TRUE);
+    if (rc != GT_OK)
+        printf(" [MFG] cpssDxChBrgGenArpTrapEnable fail , rc = %d\n", rc);
+    /* ======================================================================================================================== */
+
+    for(counter = 0 ; counter < packetNum ; counter++)
+    {
+        rc = cpssDxChNetIfSdmaSyncTxPacketSend(DEVNUM, &pcktParams, sendPktBuffList, sendPktBuffLenList, numOfBufs);
+        if(rc != GT_OK)
+        {
+            printf(" [MFG] cpssDxChNetIfSdmaSyncTxPacketSend fail , rc = %d\n", rc);
+            return rc;
+        }
+    }
+
+    cpssOsCacheDmaFree(sendPktBuffList[0]);
+#if 0   /* Print out will cause adding test time */
+    memset(cmd_buf, 0, sizeof(cmd_buf));
+    sprintf(cmd_buf, "echo \"  # Port %d SendPacketFromCPU End time:\" &>> %s", portNum, LOG_PCIE_STRESS_TIME);
+    rv_s = system(cmd_buf);
+    memset(cmd_buf, 0, sizeof(cmd_buf));
+    sprintf(cmd_buf, "%s &>> %s", DATE_PCIE_TRAFFIC, LOG_PCIE_STRESS_TIME);
+    rv_s = system(cmd_buf);
+#endif
+    return GT_OK;
+}
+
 int Get_MAC_Temperature (void)
 {
     GT_32     temperature = 0;
@@ -148,7 +430,7 @@ void Check_QSFP_Origin_Serdes_Setting()
 
 GT_STATUS Get_Port_Status(int portNum)
 {
-    int rv;
+    int rv = 0;
 
     rv = cpssDxChPortManagerStatusGet(DEVNUM, portNum, &portMgrData);
     /* printf(" # debug # port %d :: interface = %d , speed = %d , FEC = %d , status = %d\n", portNum, portMgrData.ifMode, portMgrData.speed, portMgrData.fecType, portMgrData.portState); */
@@ -158,7 +440,7 @@ GT_STATUS Get_Port_Status(int portNum)
 
 GT_STATUS PortMgr_State_Set(int portNum, CPSS_PORT_MANAGER_STATE_ENT state)
 {
-    GT_STATUS                    result;
+    GT_STATUS                    result = GT_OK;
 
     /* Get current port's status first */
     Get_Port_Status(portNum);
@@ -736,7 +1018,7 @@ void Restore_Default_Vlan(void)
 
 GT_STATUS Vlan_Mode_Set (IN GT_U8 mode)
 {
-    GT_U16 p, vid, vlan_count, vlan_first_diagnal;
+    GT_U16 p, vid, vlan_count;
     GT_PORT_NUM port;
     CPSS_PORTS_BMP_STC port_bmp, port_tag;
     CPSS_DXCH_BRG_VLAN_INFO_STC vlan_info;
diff --git a/cpssEnabler/mainSysConfig/src/appDemo/userExit/dxCh/appDemoDxChEventHandle.c b/cpssEnabler/mainSysConfig/src/appDemo/userExit/dxCh/appDemoDxChEventHandle.c
index 497d45c..ddd1859 100644
--- a/cpssEnabler/mainSysConfig/src/appDemo/userExit/dxCh/appDemoDxChEventHandle.c
+++ b/cpssEnabler/mainSysConfig/src/appDemo/userExit/dxCh/appDemoDxChEventHandle.c
@@ -130,6 +130,15 @@ GT_STATUS appDemoDxChNetRxPktHandle
     IN GT_U8                                queueIdx
 )
 {
+    /* Pegatron PCIe stress test add */
+    extern GT_STATUS MFG_Stress_Test_Rx
+    (
+         IN GT_U32                       numOfBuff,
+         IN GT_U8                        *packetBuffs[],
+         IN GT_U32                       buffLen[]
+    );
+    /* Add End */
+
     GT_STATUS                           rc;
     GT_U32                              numOfBuff = BUFF_LEN;
     GT_U8                               *packetBuffs[BUFF_LEN];
@@ -159,9 +168,14 @@ GT_STATUS appDemoDxChNetRxPktHandle
 
     if(evHandler)
     {
-        rxEventHandlerDoCallbacks(evHandler, evType,
-            devNum,queueIdx,numOfBuff,
-            packetBuffs,buffLenArr,&rxParams);
+        /* Pegatron PCIe stress test add a case */
+        rc = MFG_Stress_Test_Rx(numOfBuff, packetBuffs, buffLenArr);    /* MFG_Stress_Test_Rx function defined in mfg_gemini.c */
+        /* if these packets are not processed by MFG codes */
+        if (rc != GT_NO_MORE) {
+            rxEventHandlerDoCallbacks(evHandler, evType,
+                devNum,queueIdx,numOfBuff,
+                packetBuffs,buffLenArr,&rxParams);
+        }
     }
 
     if(appDemoPpConfigList[devNum].cpuPortMode == CPSS_NET_CPU_PORT_MODE_SDMA_E)
diff --git a/cpssEnabler/mainSysConfig/src/appDemo/userExit/userEventHandler.c b/cpssEnabler/mainSysConfig/src/appDemo/userExit/userEventHandler.c
index fdf9482..a9ab815 100644
--- a/cpssEnabler/mainSysConfig/src/appDemo/userExit/userEventHandler.c
+++ b/cpssEnabler/mainSysConfig/src/appDemo/userExit/userEventHandler.c
@@ -21,6 +21,7 @@
 #define _BSD_SOURCE
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 /* Add End */
 
 #if (defined CHX_FAMILY)
-- 
2.7.4

