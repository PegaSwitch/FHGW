delaytime=0.05

## Time
export TZ='Asia/Taipei'

## Platform detect, to decide gloable variables.
source ${HOME}/mfg/mfg_sources/platform_detect.sh

function Write_I2C_Device_Node()
{
    i2c_bus=$1
    i2c_device=$2
    i2c_register=$3
    i2c_data=$4

    if (( $FLAG_USE_IPMI == "$FALSE" )); then
        i2cset -y $i2c_bus $i2c_device $i2c_register $i2c_data
    else
        swallow_empty_line=$( { ipmitool raw $BMC_NET_FUNCTION $BMC_I2C_SET $i2c_bus $i2c_device $i2c_register $BMC_I2C_ACCESS_DATALEN_ONE $i2c_data ; } 2>&1 )
    fi
    sleep $delaytime
}

function Read_I2C_Device_Node()
{
    i2c_bus=$1
    i2c_device=$2
    i2c_register=$3

    if (( $FLAG_USE_IPMI == "$FALSE" )); then
        i2cget -y $i2c_bus $i2c_device $i2c_register
        sleep $I2C_ACTION_DELAY
    else
        value_get_through_ipmi=$( { ipmitool raw $BMC_NET_FUNCTION $BMC_I2C_GET $i2c_bus $i2c_device $i2c_register $BMC_I2C_ACCESS_DATALEN_ONE ; } 2>&1 )
        sleep $I2C_ACTION_DELAY
        if [[ "$value_get_through_ipmi" == *"Unspecified error"* ]]; then
            ipmi_value_toHex=0x00
        else
            ipmi_value_toHex=$( { printf '0x%02x\n' "$((16#$(expr substr "$value_get_through_ipmi" 2 2)))" ; } 2>&1 )    # orig value format is " XX" , so just get XX then transform as 0xXX format.
        fi
        echo $ipmi_value_toHex    # this line is to make return with value 0xXX
        return
    fi
}

## check IP was DHCP or not, if not, force it as default IP.
check_ip_exist=$( { ifconfig $ETHTOOL_NAME | grep 'inet addr:' | cut -d: -f2 | awk '{ print $1}' ; } 2>&1 )
if [ -z "$check_ip_exist" ]; then
    ifconfig $ETHTOOL_NAME 192.168.1.1 up
    echo " # No DHCP link, so manual config $ETHTOOL_NAME IP as 192.168.1.1"
fi

if [[ ! -f "$platform_init_flag" ]]; then
    if (( $FLAG_USE_IPMI == "$TRUE" )); then
        swallow_empty_line=$( { ipmitool raw $BMC_NET_FUNCTION $BMC_SENSOR_MONITOR_REG $BMC_SENSOR_DISABLE ; } 2>&1 )    # disable BMC sensor monitor to prevent job was paused or interfered in.
    fi

    ## 20200928 Add : Base on BDX CPLD v9, additional bit configure whether auto switch console to BMC.
    if [[ "$SUPPORT_CPU" == "BDXDE" ]] && [[ "$FLAG_USE_IPMI" == "$TRUE" ]]; then
        ctrl_reg_status=$( { Read_I2C_Device_Node $I2C_BUS_ARBITER_AND_AFTER $NPU_CONTROL_CHIP_ADDR $BDX_LED_CNTL_REG ; } 2>&1 )
        ctrl_led_value=$(( $ctrl_reg_status & ( ~ $BDX_CONSOLE_AUTO_MASK ) ))
        Write_I2C_Device_Node $I2C_BUS_ARBITER_AND_AFTER $NPU_CONTROL_CHIP_ADDR $BDX_LED_CNTL_REG $ctrl_led_value
    fi

    sleep 1
    source ${MFG_SOURCE_DIR}/onie_syseeprom_init.sh

    if (( $FLAG_USE_IPMI == "$TRUE" )); then
        swallow_empty_line=$( { ipmitool raw $BMC_NET_FUNCTION $BMC_SENSOR_MONITOR_REG $BMC_SENSOR_ENABLE ; } 2>&1 )
    fi

    ## turn-off kernel msg for PT request.
    echo 3 > /proc/sys/kernel/printk

    printf "\nDate : "
    date
    printf "\n"

    ## create semaphore to prevent re-init again.
    touch $platform_init_flag
    sync
    sleep 2

    ## customize setting for each project.
    #bash /root/mfg/mfg_sources/platform_init.sh
    bash ${MFG_WORK_DIR}/platform_initialization/platform_init_GEMINI.sh
fi

